#include "itktfCompareVisitor.h"
#include "itktfRegressionSupport.h"
#include "itkImage.h"
#include "itkImageFileReader.h"
#include "itkImageRegionConstIterator.h"

#include "itktfDifferenceImageFilter.h"
#include "itktfRegression.h"


namespace itk {

CompareVisitor::CompareVisitor( void ) 
{    
  this->SetImageInsightToleranceOff();
}
  
void CompareVisitor::SetImageInsightToleranceOff( void ) 
{ 
  this->SetImageInsightTolerance( 0.0, 0, 0 ); 
}

void CompareVisitor::SetImageInsightTolerance( double intensityTolerance, 
                                         unsigned int numberOfPixelTolerance,
                                         unsigned int radiusTolerance )
{
  m_IntensityTolerance = intensityTolerance;
  m_NumberOfPixelsTolerance = numberOfPixelTolerance;
  m_RadiusTolerance = radiusTolerance;
}


    
void CompareVisitor::Visit(testutil::MeasurementFile &m) 
{
  testutil::MeasurementFile *input;
  if ( m.GetAttributeType() == "image/itk" &&
       (input = dynamic_cast<testutil::MeasurementFile*>(this->_baseline)) )
    {
    const char *testImageFilename = m.GetFileName().c_str();
    const char *baselineImageFilename = input->GetFileName().c_str();

    std::cout << "Comparing test image: \"" << testImageFilename << "\" to baseline image: \"" << baselineImageFilename << "\"" << std::endl;
    
    if ( this->RegressionTestImage(testImageFilename, 
                                   baselineImageFilename, 
                                   false,
                                   m_IntensityTolerance,
                                   m_NumberOfPixelsTolerance, 
                                   m_RadiusTolerance ) )
      {
      // image are different
      this->compareResults = false;
      }
    else
      {
      this->compareResults = true;
      }
    }
  else 
    {
    this->testutil::CompareVisitor::Visit(m);
    }
}

int CompareVisitor::RegressionTestImage (const char *testImageFilename, 
                                         const char *baselineImageFilename, 
                                         bool reportErrors,
                                         double intensityTolerance,
                                         unsigned int numberOfPixelsTolerance, 
                                         unsigned int radiusTolerance )
{
  // Use the factory mechanism to read the test and baseline files and convert them to double
  typedef itk::Image<double, ITK_TF_DIMENSION_MAX>        ImageType;
  typedef itk::ImageFileReader<ImageType>                   ReaderType;

  // Read the baseline file
  ReaderType::Pointer baselineReader = ReaderType::New();
  baselineReader->SetFileName(baselineImageFilename);
  try
    {
    baselineReader->UpdateLargestPossibleRegion();
    }
  catch (itk::ExceptionObject& e)
    {
    std::cerr << "Exception detected while reading " << baselineImageFilename << " : "  << e.GetDescription();
    return 1000;
    }
  
  // Read the file generated by the test
  ReaderType::Pointer testReader = ReaderType::New();
  testReader->SetFileName(testImageFilename);
  try
    {
    testReader->UpdateLargestPossibleRegion();
    }
  catch (itk::ExceptionObject& e)
    {
    std::cerr << "Exception detected while reading " << testImageFilename << " : "  << e.GetDescription() << std::endl;
    return 1000;
    }

  // The sizes of the baseline and test image must match
  ImageType::SizeType baselineSize = baselineReader->GetOutput()->GetLargestPossibleRegion().GetSize();
  ImageType::SizeType testSize = testReader->GetOutput()->GetLargestPossibleRegion().GetSize();  
  if (baselineSize != testSize)
    {
    return 1;
    }

  // todo change to some kind of fuzzy test. What is the required
  // resolution of spacing?
  ImageType::SpacingType baselineSpacing = baselineReader->GetOutput()->GetSpacing();
  ImageType::SpacingType testSpacing = testReader->GetOutput()->GetSpacing();
  if (baselineSpacing != testSpacing)
    {
    return 1;
    }
  
  // todo change to some kind of fuzzy a test.
  ImageType::PointType baselineOrigin = baselineReader->GetOutput()->GetOrigin();
  ImageType::PointType testOrigin = testReader->GetOutput()->GetOrigin();
  if ( baselineOrigin != baselineOrigin )
    {
    return 1;
    }

  // todo add orientation

  
  unsigned long status =
    Regression::CompareImage< ImageType >( testReader->GetOutput(),
                                           baselineReader->GetOutput(),
                                           intensityTolerance,
                                           numberOfPixelsTolerance,
                                           radiusTolerance );
  

  return (status > numberOfPixelsTolerance) ? 1 : 0;
}

}

